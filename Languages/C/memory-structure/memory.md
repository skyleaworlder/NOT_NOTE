# 内存相关

## 一、程序内存结构

以 `x86-gcc-9.2.0` 的编译结果为例：

总的来说分为：

* 代码段 (0x004005bd 附近)
* 数据段 (0x00601048 附近)
  * 已经赋初值的全局变量；
  * 静态变量。
* BSS 段 (0x00601070)
  * 尚未赋初值的全局变量。
* 堆 (0x00602010 附近，向高地址增长)
  * 动态内存申请时分配的空间。
* 栈 (0xffffe324 附近，向低地址增长)
  * 函数栈帧；
  * 自动 / 动态 / 局部变量。

由于我不敢操作 `windows` 上的 `aslr`，我换到了我自己的服务器上面。`gcc version: 4.8.5`，但我的服务器是 `x64`，由于缺少库，也编译不出 `32 bit` 的程序，所以只好凑合看了。

这是部分结果：

```result
打印 max 函数起始地址
0x004005bd
打印程序初始程序 main 地址
0x0040072a
打印各全局变量(已初始化)的内存地址
0x00601048
0x0060104c
0x00601050
打印各静态变量的内存地址
0x00601060
0x00601064
0x00601068
打印各全局变量(未初始化)的内存地址
0x00601070
0x00601074
0x0060106c
打印 malloc 分配的堆地址
0x00602010
0x00602040
0x00602060
打印 argc 地址
0xffffe30c
打印 argv 地址
0xffffe300
打印各局部变量的内存地址
0xffffe324
0xffffe320
0xffffe31c
```

其实可以看出，在 `aslr` 关闭的情况下，堆的位置不在飘忽不定，就是像网上搜到的一些图一般，落在程序空间的最后面：

![进程内存结构](https://i.stack.imgur.com/KJGw7.png)

所以如果下次再有人问我 **“C/C++ 语言内存分配方式有几种”**，那我大概会这样简要回答：

```chinese
我想这个问题包括很多方面。
如果将代码段也视作内存，那我觉得写代码也算是分配内存空间了。

但如果不这么说的话，只考虑代码直接应用到的数据，那应该包括三个部分。

第一个方式是静态内存区域的分配，比如 BSS 和数据段。
第二个方式是栈空间的申请，一个局部变量的声明 / 定义也能分配到一块内存。
第三个方式是堆空间的申请，比如 malloc / calloc / new 等方式。
```

## 二、内存对齐

```c
struct A {
  int a;
  double b;
  char c;
};

int main() {
  printf("%d\n", sizeof(struct A));
}
```

这个运行结果是 24，但是：

```c
struct A {
  int a;
  double b;
  char c;
} __attribute__ ((packed));

int main() {
  printf("%d\n", sizeof(struct A));
}
```

其运行结果就变成了 13。结构体内需要 8 字节 8 字节地对齐：

* `int a` 4 字节，需要后补 4 字节；
* `double b` 8 字节，不需要补充；
* `char c` 1 字节，需要后补 7 字节。

但是开启了 `__attribute__ ((packed))` 就可以取消内存对齐了。`__attribute__` 可以为 **函数、变量、类型** 设置一些属性。
