# 第三章-数据链路层

重中之重是要理解为什么有这么一层，这一层是干什么的。

我现在算刚刚入门这个课，总会有 “为什么非要分层啊” 这个疑惑。其实冠冕堂皇的答案我能给出不少——“分层是计算机科学的基本思想之一”、“解耦合”、“简化总功能实现逻辑”……

但是仔细想想，为什么网络层不和数据链路层合在一起？（白痴问题）

我觉得，如果要全面回答这个问题，应该看完这一节的内容了。

## 一、选择分层思想

先不说为什么选。我一时很难从原因出发阐述这一问题的答案，我愿意做一个假设——“假设这里有一个数据链路层，看看它能干什么，以及能干得多好”。（假设一个东西存在，然后反推它存在的必要性，是中国教材常用的写作手法）

数据链路层上接网络层，下连物理层。直连物理层意味着数据链路层需要 **处理物理层可能发生的差错**。连接网络层说明该层需要 **为网络层提供接口**（先不管是什么接口）。

### 1. 对于物理层

物理层传上来的是连续的 “01” 串，其中可能多一个、少一个、错一个，哪怕错误率很多，也是错。数据链路层必须要选择一个算法，这个算法要求能够检验 **从物理层得到的数据流** 是否准确。“**成帧**” 是数据链路层的做法。

需要注意的是，物理层传上来的是 **连续** 的串。连续的东西错了一个地方很难被发现。我小学写作文的时候，喜欢打草稿，最后再把修改好的作文誊抄到作文本上。但由于个人注意力、精神力等方面的缺陷，得到一篇无差错的 600 字作文实在是有些困难。因此我当时想了个办法，每次抄三句话。抄完三句话就休息一段时间。（从小就会摸鱼了）休息的时间没有多少，但是准确率大大提升了。

数据链路层处理 **连续** 串的思路和我类似，但不完全是一个道理。数据链路层将连续的 “01” 串划分成离散的 **帧**，对每个帧做校验。

### 2. 对于网络层

其实没那么多好想的。数据链路层接到的物理层传来的数据，不可能是自动生成的。肯定是另一边通过 “网络层-数据链路层-物理层” 处理传过来的。网络层是网络层的事。

## 二、帧设计

本来想写 “协议设计” 的，但是想了下，后面应该全是协议设计，计网这本书讲的也都是协议如何设计。

所有的协议首先要考虑的是如何组织这些比特，如何用 **人类 / 计算机** 都能够理解的方式定义。不少协议格式将数据划分成了 `Header` 和 `Body`，有的可能要加一个 `Tailer`。

现在假设我的面前已经有了一个现成的协议，我自己要写一个 “协议分析器”，那我该怎么写呢？首先我要做的肯定是定义一系列的 `struct` 或者 `class` 或者其他数据格式。因为协议已经给出，总之要适配协议为先。

那么在适配的时候就会出现一些不得不考虑的事情：

* 有些协议它字段是 `optional` 的（甚至 `Body` 都是 `optional` 的）；
* 有的字段是变长的；
* 有的字段用 `ASCII`，有的使用数字，有的需要传浮点数。

那该怎么处理这些情况？

这其实就是序列化吧？如果是应用层协议的话，现在有很多工具可以通过给定的定义，自动生成 “量小、利用率高” 的协议表示和协议解析 / 生成函数。

但人要是手写的话，就不得不自己考虑这些事情。

绕了这么大圈子，直接提一个经典问题：“**我怎么知道一个帧有多长？**”

### 1. 字节计数

这不是废话，在最前面加一个 `Len` 就行了。但是万一它出差错了呢？

### 2. 字节填充标志字节

前面加一个标志 `FLAG`，帧尾也加一个相同的。两个相同的 `FLAG` 表示上一帧的结束和下一帧的开始。但万一 `Body` 里面也需要传输类似的连续比特流呢？

其实这个和 `printf("\\")` 是一样的。`Body` 内如果要传，加个 **转义符** 就可以了。如果要传转义符，就转义符+转义符。

`FLAG` 叫 **标志**，加转义符叫 **填充**。

### 3. 比特填充标志比特

很明显，上面字节填充，粒度是字节，也就是八个比特。

上课的时候，当时主要是以 **HDLC** 为例，帧的开头和结尾都是 `0x7e`。`7e` 可能见的比较多，`01111110` 可能就见的比较少了，但实际上是一样的。

这里有连续的 6 个 1，因此在 `Body` 中，碰到连续的 5 个 1 就应该加一个 0。以此来表示与 `FLAG (01111110)` 的区别。很明显，这个的效率远远高于 **字节填充标志字节**。

### 4. 物理码违禁

不太懂，我物理层学得太差了，只能理解一个大概。

物理层传上来的 **比特流** 也不是什么都有的。有一些连续比特，在某些编码方式下是不可能出现的。那么数据链路层完全可以利用 **物理层编码** 来标识 **数据链路层帧** 的开始和结束。（完全不懂，只是阅读理解）

## 三、差错控制

大概是这么一个逻辑。得到了一个帧：

* 检查一下
  * 检查出错误了，尝试校错
    * 校错成功了，通过
    * 校错失败，重传
  * 正确，通过

而对于一串帧，可能有：

* 检查一下
  * 发现不应该是这个帧
    * 多发了
    * 漏发了
  * 正常，通过
