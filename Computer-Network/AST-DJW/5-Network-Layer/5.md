# 第五章-网络层

网络层是处理 **端到端** 的最底层。

对于我正在使用的计算机，它若要和另外一个计算机通信。中间的所有设备我都可以把它视作一个黑盒。从我看来，我好像就是直接连接了对方的计算机一样。

中间那个被我视为黑盒的事物，实际上是一系列的设备，这里面有交换机，也有路由器，当然还有其他可能的设备。这些都是 **ISP** 下的设备。它们（路由器）运行着某种算法，将我的消息传给另一方。

## 一、两种连接

### 1. 无连接服务过程

无连接 <===> 数据报网络。

每个路由器都维护一个表，这个表的 “键” 是 **`target`**，“值” 为 **下一跳路由器**。
对于网络内的每一个节点，在一个路由器内，都可能有一个下一跳路由器地址。

当机器打算发送一个数据报的时候，**ISP** 下的路由器们通过查阅自己维护的表，来将数据报一步步送到最后的目的地。在某本关于 “分布式算法” 的机工书里面被当作例子来精讲。

在这个过程中，路由表是一个关键角色。有关这个路由表，就诞生了以下问题：

1. 路由表怎么初始化 / 添加项 / 删除项？
2. 路由表是不是一成不变的，如果不是，该怎么变化？
3. 路由表是如何对数据报传递产生影响的？

其实还有很多问题，不过可能有些问题就不在计网的讨论范围之内了。

### 2. 有连接服务过程

就是固定好了一个，它不会改变路由表，写了就是写了。

但是在处理 **多主机连接路由器** 的时候也有一些问题，具体参见 **多协议标签交换 (MPLS)**。

## 二、路由算法

对路由算法的要求相当之高。问题来源于这些事实：

1. 大多数通信过程中间并不是只需要一个路由器就够了；
2. 网络拓扑结构可能经常改变；
3. 开发路由算法的时候，计算机正面临快速发展的时期；
4. 计算机若要走向普通人，那就需要让普通人觉得好用。

这蕴含了对很多特性的要求。比如第一个，中转节点一旦多了，设备的失效就可能必须纳入考虑范畴；而网络拓扑结构的易变，可能需要路由算法即插即用；普通人不懂什么交换，他只想要一个对自己而言稳定的网络环境……

总之要求是很多。

### 1. 单源最短路径 —— Dijkstra 算法

学离散应该学过。虽然离散距离现在已经一年半了，但我还清晰地记得当时离散最后一道题就考的 `Dijkstra Algorithm`。可惜的是，那个算法是我临考前 $5$ 个小时 “速通” 的，可以说考完了之后便一点印象都没有了。

现在，我今非昔比。相信可以用更易懂的语言来描述它。

#### i. Dijkstra 的精髓

个人以为是一个以 “距源长度” 为核心的 “伪优先队列”。（仅是个人观点）

而理解为什么它是精髓，就需要触碰算法最底层的逻辑。

#### ii. 先提一个暴论

```chinese
下一个操作对象是，那个 “距源长度” 最短的节点。
```

如果这个是对的，那么 “优先” 的概念呼之欲出。但为什么不是正经的 “优先队列” 呢？当然是因为在算法过程中，不需要 `enqueue`，所有节点一开始都在。不如说该数据结构是一个 “当其中某个元素的值遭到修改后，需要重排序” 的数组。

而这句话为什么对呢？我不会数学上的证明，只能从感觉上大概混一下：

试想，我现在是要寻找下一个操作对象，那么什么时候开始寻找呢？应该是 **操作过上一个节点之后**。按道理，我这句话是句废话。但在 `Dijkstra Algorithm` 中，操作节点意味着固定一个节点的 “距源长度”，相当于将那个点之前的 “距源长度” 视作单源最短路径长度。

而且可以从中得出一个结论：上一个操作节点，在已有的操作节点中，“距源长度” 是最大的；但曾经，它也是在未操作节点中 “距源长度” 最小的。（因为是一个一个从小到大选的）

比如书中的图 5-7(c) ：已操作节点的单源最短距离为 $[0, 2]$，未操作的自然是 $[4, 6, 9, +\infty, +\infty, +\infty]$。

那么按照算法，肯定选 $4$。并且我们需要明确一点：**任意操作节点，只能将未操作的节点的 “距源长度” 再度缩小，但永远不可能小于当前节点**。（而这是因为 `Dijkstra Algorithm` 的限制之一：“两节点间距离不能为负”，如果为负，那最小可能会失去意义，可能会出现负无穷的环路；同时，已经操作过的节点的 “距源距离” 很可能会变小）

并且可以得到一个结论：**已经选择的节点，不可能通过对剩余未操作节点的操作，再次降低 “距源长度”**。

也就是说我现在选了 $4$，可能会让后面的 $[6, 9, +\infty, +\infty, +\infty]$ 变小一些，变成 $[5, 6, 9, \infty, \infty]$，但绝不会变成 $[3, 6, 9, \infty, \infty]$。更不可能让前面的 $[0, 2]$ 变成 $[0, 1]$。

这像是一种分治思想。只不过这里交给了节点去 “自治” 属于自己的问题。和快排相似，只不过快排的 “属于自己的问题” 是当前数组中大于 / 小于选定基准值的两个元素数组而已。

#### iii. 程序

```phcode
def func Dijkstra(Graph G) {
    def Queue q

    sort(G.Nodes, G::Node::dist)
    q.enqueue(G.Nodes[0])
    while (!q.empty()) {
        G::Node n = q.dequeue()
        for (node in n.nextNodes) {
            if (G::hasOperated(node))
                continue;
            node.dist = (node.dist is +\infty) ? node.len : node.dist+node.len
        }
        sort(G.Nodes, G::Node::dist)
        if (G.Nodes.len is 0)
            q.enqueue(G.Nodes[0])
    }
}
```

### 2. 泛洪算法

唯一需要避免的是 **表无限膨胀**。

膨胀的原因是，路由器需要记录所有来源的数据报。泛洪本来就要发送大量的数据报，那么就非常有可能会把路由器挤爆。

做法有很多，最极端的自然是书上记录的这个方法：只记录收到的最大序列号，小于该序列号的全部丢弃。不过这需要源发方的配合了。

### 3. 距离矢量算法

想法是很美好，也是很容易理解的。

对于网络中的某一个节点，它有若干个邻接节点。该节点和它的邻接节点 **经常性互发路由表**。那么就可以通过 **路由表中的延迟** 以及 **互发消息的真实延迟** 计算出属于该节点的路由表。

这是有道理的。

* 首先，任意节点，想要与网络内的节点通信，必须首先经过它的邻接节点。
* 其次，关于邻接节点路由表中记录的延迟，该节点视之为 “可靠的”，也就是该节点不关心。
* 再次，该节点只关心自己和邻接节点交流路由表时的 **真实延迟**。
* 最后，如果假设传过来的路由表是对的，那么再加以自己保证正确的 **真实延迟**，那么最后得出的结论一定是正确的。

#### i. 但分布式总能带来些新花样

节点失效在所难免。

当某节点将自己的路由表交给它的临近节点后，如果它失效了该怎么办？

由于这个网络中不再有任何节点可以 `access` 那个节点，导致路由表中有关它的 “距离” 开始疯狂 `+1 +1 +1 +1...`。

在书中被称作 **无穷计算问题**。

### 4. 链路状态路由

与之前的分布式路由算法不同。这个虽然也是分布式算法，但是这个 “分布式” 具体体现在 **路由表的分发和接受** 上。

但到了计算的步骤时，却是在本地跑 `Dijkstra Algorithm`。而这就意味着 **链路状态路由需要每台路由器都有到整个网络中所有路由器的距离**。这也等价于 **每台路由器都要把自己的路由表发给其他所有路由器**。

算法一共分成五个部分：

1. 邻居节点的发现；
2. 设置与邻居节点的距离；
3. 链路数据包构造；
4. 将包发送给其余所有路由器，接受其余所有路由器的包；
5. 计算单源最短路径。

重点是第 4 点。该算法还是采用了泛洪法。那么泛洪法拥有的所有缺点，都需要在构造 **链路数据包** 的时候加以规避。

假设每个节点有 $k$ 个邻居节点，整个网络有 $n$ 个节点，那么显然每个节点在计算单源最短路径的时候，需要处理 $kn$ 大小的数据。如果节点数量膨胀，链路状态路由算法可能表现非常一般。

### 5. 层次路由

为了解决上面所说的 $n$ 过大，自然有了层次化想法。

有的时候分层是为了将问题分化，将原本复杂的问题分解为若干个正交的、有逻辑先后顺序的子问题。但有的时候却只是为了缩小问题范围，在所有范围内解决类似的问题。

层次路由也是这样。

如果是使用 “链路状态路由” 的话，原本需要考虑的是 “如果我网络里面有 $10000$ 个节点，我需要存 $10000$ 个路由项”。但若是将每 $1000$ 个路由划分为一个路由簇，岂不是每个机器只需要存 $(1000 + \dfrac{10000-1000}{1000})$ 个路由项了吗？

而不需要考虑原本那么多。分的越细，越是不需要考虑那么多路由项。

### 6. 广播路由

我也不太清楚，可能广播是路由器的本领。

假设我想要向 $A, B, C, D, E$ 发送数据报。当前这个路由器 $L$ 与三个路由器 $M, N, O$ 相连。且 $A, B, D$ 在 $M$ 下。$C, E$ 在 $N$ 下。

那么当前路由器 $L$ 会不理睬 $O$ 口，激活 $M, N$ 两个口，同时生成两个副本报文。一份报文中，广播的对象变成了 $A, B, D$ 而非原先的 $A, B, C, D, E$；另一份报文中变成了 $C, E$。

### 7. 其他路由

没有精力看了，以后再补吧。

## 三、拥塞控制

问题不是靠无脑增加资源就能解决的。

假设一个每秒处理 10 个包、内存也只能容纳 10 个数据包的路由器拥塞了。使它内存能够容纳 1000 个包并不是一个好方法。因为它的处理能力没有上去，届时会发送延迟过高的数据包。

但这里的意思不是说增加资源就不行。**增加资源** 和 **减少负载** 永远都是两类拥塞控制方法。

### 1. 朴素的拥塞控制思路

* 如果路由器能知道整体网络（周围局部网络）的拥塞状况就好了，这就可以随时间调整资源了；
* 如果路由器在拥塞的时候可以让源少发点就好了。

原本路由器只是做一个 **转发** 的工作而已。在讨论算法时，我们会少考虑很多实际情况，会去假设路由器有无限的内存，以及无限的处理能力。（当然，讨论算法时，算法会去优化存储相关事宜，但只是从理论数据量去考虑，而并非实际情况）

为完成第 1 个想法，那就需要 **感知流量**；而完成第 2 个需要路由器和源端持续通信。

### 2. 流量感知路由

路由器仅仅通过自己的负载来改变路由，是不好的。可能会引起 “路由振荡”。具体可见图 5-23。

### 3. 流量调节

假设现在有个路由器要炸了，它该如何告诉源端不要发那么快呢？

#### i. 最直接的想法

当然是直接告诉源端。通过发送一个 **抑制包**，减缓源端一定的发送流量。

#### ii. 让接受方转达

路由器在接收到源端发来的包时，把 **抑制标记** 打在包上，发给接受方。然后由接受方的响应包 `NOTIFY` 源端减小流量。

#### iii. 逐跳后压

接受方转达可能很慢，慢就是延迟，延迟就是更多未被控制的流量涌入路由器。

需要明确的是，**逐条后压也是让接受方转达**。但是每一条的路由器都变成了 **抑制标记** 的作用对象。原本 **抑制标记** 只是 `NOTIFY` 源端，而现在所有的中间路由器都要受到影响。

进而，流量并非从源端开始一步步减小，而是从倒数第一个路由器开始减小，**源端反而是最后一个减小流量的地方**。看下图 5-26

#### iv. 负载脱落

不玩了，直接躺平。无法处理的数据包就直接丢掉吧。

但丢包也是一种艺术，怎么丢？丢那个？对于不同的应用程序，有不同的丢包策略：

* `wine`：旧的比新的好；
* `milk`：新的比旧的好；
* 其他策略，比如谁出钱多，比如随机丢。

## 四、服务质量

后面会一直讨论这个东西，直到宇宙毁灭。

通常要传输的东西不是简简单单的一个数据包可以概括的，它会被拆成很多个数据包，这些数据包如果在交换网络中会散开来，最后汇聚到目标主机；如果是在面向连接的网络中，会沿着一条虚电路持续传输。对于这么一个过程，这么一系列数据包，会有一系列参数描述它的 **好 / 坏**。

* 带宽；
* 延迟；
* 抖动：延迟的变化 / 数据包到达时间的变化；
* 丢失。

这四者共同构成了描述 **服务质量** 的需求。

不同的网络服务对它们的需求是不一样的。当然，这里的 **需求** 有 **最低承受界限** 的意味。所有指标都拉满自然是最好的，但是当四者无法同时满足时，我们对于特定的服务，需要首先满足特定的指标。

### 1. 流量整形

有许多需要考虑的事情，首当其冲的是 “**协议**”。

这里的协议指的是：我怎么知道你这个服务提供方能否提供我想要的呢？

“这个实际还是很好办。既然是协议，那就和其他协议一样，交互个几次，确认几下就可以了。”

这种抽象的话自然是很好理解，也很好说。但需要注意，**流量整形** 的双方，一方是用户，另一方是网络提供方。发出质问的是用户，用户有何种何种应用程序，问网络提供方可否满足对应需求。详情可见 `SLA`。

### 2. 漏桶 / 令牌桶

这是两个思路。或者说是关于 “桶” 这个事物的两种描述。

#### i. 漏桶

重点在这个 “漏” 字儿。讲真的，无论是看书，还是看 `PPT`，它们都是假设你已经会了再去讲的。那一点概念都不知道的话，看那本书就简直像天书一样。

**“漏桶” 中，“请求” 就是桶里的 “水”**。来了多少请求都往桶里面装，装不下了就溢出来，不处理。但是一旦装进了桶里，迟早会从桶的漏口出流出。而 **“水流出” 就代表着 “请求被处理”**，放在这里就是 “路由器处理了发来的数据包”。

无论来的多凶猛，漏桶始终可以以小于、最多等于的速率处理请求。也就是说，**“漏桶” 能够平缓流量**。

#### ii. 令牌桶

令牌桶书上写的是一团乱，配图也非常糟糕。

**“令牌桶” 中的 “水” 是 “令牌”，而非 “请求”**（不然为啥叫令牌桶）。如果要处理到来的请求，就必须 **从令牌桶中获取令牌**，否则丢弃。往令牌桶中 “注水”，实际上就是在 “加令牌”，有了更多的 “令牌”，就允许处理更多的请求。

无论那一瞬间有多少请求，只要桶中还有令牌，都可以一下子处理。也就是说，**“令牌桶” 的最大处理能力是理论无穷的，可以处理突发流量**。

但令牌桶肯定也有一个最大处理速率。假设能够处理能力是 $M$，桶容量为 $B(bucket)$，令牌生成速率为 $R$，则有 **突发时间**，也就是 **最大处理速率的最长持续时间 $S$ 为：**

$$
B + RS = MS \Rightarrow S = \dfrac{B}{M-R}
$$

总结一下，漏桶和令牌桶，一个处理能力体现在 “漏口漏水速率”，一个体现在 “桶中令牌个数”。二者完全不是一回事。

### 2. 流量调度

刚刚做的其实是 “整形”。这个 “整形” 能直接体现在流速上，也就是单位时间处理数据包的数量。也就是说，无论是令牌桶还是漏桶，这些技术都是为了将流量压缩到一个给定的级别上。

但是这个级别如何确定？有没有什么算法？这些问题就不是二者考虑的了。

而这个 “流速” 还取决于特别多的因素：`band width, buffer size, cpu frequency...`

我们知道，如果能够到达目的地，那么一定有一条最优的道路。但是在大多数可达的情况下，往往不止有一条可达的通路。虽然有些通路需要消耗更多的时间，但是流量太大，最优通路可能不堪重负。

**调度** 就是为 **同一个流中** 的 **数据包** 分配路由器资源的算法。同时，**调度** 也是为 **不同流 / 竞争流中** 的 **数据包** 分配路由器资源的算法。

这是很明显的。如果链路可承受负载很小，那么哪怕只有一个数据流，也需要调度到不同的通路上去；如果链路可承受的负载比较大，那么流多一点也会让它左支右绌。

#### i. FIFO / 公平队列 / 加权公平队列

其实读书不仔细就会觉得很奇怪。明明说好了是调度，为什么后面变成了 **如何从队列中取元素**。

因为我要调度，调度的客体是数据包。管理数据包的方式可以有很多，归根揭底是把这些数据包放在一个 “集合” 里面，或者是一个数据结构里面。不同的数据结构有不同的特征，比如我们肯定不希望 **先进后出**，所以用的是 “队列”。队列的性质就等价于 **调度** 的算法。

这里需要说明一些可能会误解的地方。

无论是什么调度算法，描述的都是 **一条输出链路对应 1 / x 个队列，每个队列对应 x  / 1 个输入链路**。举个例子：

**FIFO** 是对一条输出链路只有一个队列。所有的输入流发来的包都放在这个队列中。

**公平队列** 的公平体现在对 **所有流** 的公平。它为一条输出链路创建了一系列的队列。输出：输入是一对多的关系。

#### ii. 其余调度算法

累了，不看了。

### 3. 准入控制

#### i. 流协商

这个 **准入** 很贴切。如果没有符合标准，连往这个 **网络** 发请求都做不到。（或者不愿意做）

准入控制的过程，在我看来就是 **流协商** 的过程。正如书上所述：

```chinese
因为流协商过程中会涉及许多方（发送方、接受方以及沿途所有路由器）

所以必须用特定参数来精确描述流，并且这些参数是可以为各方所协商的。
```

详情可见 [RFC-2210](https://datatracker.ietf.org/doc/html/rfc2210#section-3.2)。

正如 `RFC` 这个部分下提及的 `flow-spec`，具体的协商协议与之类似。这个协商报文会从 **发送方** 开始，经过一系列路由器，到达 **接受方**。沿途每个路由器都会对其进行检查，协商内容只可删减质量，不可增加扩容。

#### ii. 资源预留 (Resource ReSerVation Protocol / RSVP)

流协商中，参数主要为：

|参数|单位|
|-|-|
|令牌桶速率|字节/秒|
|令牌桶容量|字节|
|峰值速率|字节/秒|
|最小数据包大小|字节|
|最大数据包大小|字节|

这些参数协商好了，那路由器拿到这些东西该怎么做？这些参数意味着什么？路由器能干的事情要说多，那也不算多，至少在控制方面，它大多数情况下只能调节自己，能调节的也就是自己处理数据包的速率。

所以，这些参数如何 **转化成特定资源预留** 是需要说明的。

#### iii. 聚焦路由器

是路由器管资源预留，是路由器收发数据包。那么我们可以聚焦路由器，对于一个路由器来说，它就两个功能：接受数据包 和 发送数据包。

不妨设一路由器 $R$ 每秒钟接受数据包 $\lambda$ 个，每秒向链路发送数据包 $\mu$ 个。那么很容易得出：在理想情况下，发送每个数据包需要花费 $\dfrac{1}{\mu} s$ 的时间。

然后我也不知道为什么，我不懂排队论，说是每个数据包平均延迟 $T = \dfrac{1}{\mu} \times \dfrac{1}{1-\frac{\lambda}{\mu}} = \dfrac{1}{\mu} \times \dfrac{1}{1 - \rho}$

#### iv. WFQ

我不懂啊，看不明白。

## 六、Internet 网络层

### 1. 地址

|地址|性质|
|-|-|
|物理地址|`MAC` 地址|
|`IPv4` 地址|一个全世界范围内都可以访问的地址|
|端口地址|用于标识主机进程，端口号理论范围：0~65535|
|网络地址|用于描述一个网络（比如一个子网的网络地址可能为 100.68.0.0）|
|广播地址|就子网内全部广播吧|
|环回地址|127 为网络号的地址|
|私有网 `IP` 地址|用于未连入 `Internet` 的网络|

是正常没学过计网的人都能理解的东西。

#### i. 点分十进制

因为中间用 **点** 分开，并且还使用十进制表示。所以才叫这个。

#### ii. 子网掩码

每个 `IP` 地址都由 **网络号** 和 **主机号** 两个部分组成。网络号对应的子网掩码比特均为 1，主机号对应的都是 0。

#### iii. IP 的分类

就是平常听到的 `A, B, C, D` 类地址。

根据网络号，还有对于 `IP` 地址的分类，以网络号前 1~4 个比特作标识：

|类型|标识|
|-|-|
|A|0-接剩余 31 位|
|B|10-接剩余 30 位|
|C|110-接剩余 29 位|
|D|1110-接剩余 28 位|
|E|1111-接剩余 28 位|

其中 `D` 类地址是用作组播的。前面的 `A, B, C` 类相比，`A` 类单个网络下能容纳的主机数量最多，`C` 类地址中，网络数量最多。

#### iv. 私有网 IP 地址

在三类 `IP` 中，都有私有网 `IP` 地址：

|类型|网络号|总数|
|-|-|-|
|A|10|1|
|B|172.16~172.31|16|
|C|192.168.0~192.168.255|256|

#### v. 课件精髓言论

摘自课件对 **例：Internet 中的 IP 地址** 一图的解释：

* 同一网络中，主机 / 路由器的 `IP` 地址 **同网络号**；
* 路由器总是具有 **两个 / 两个以上** 的 `IP` 地址；
* 路由器的每一个接口都有一个不同网络号的 `IP` 地址；
* 两个路由器相连的接口处，一般不指明 `IP` 地址；
* 两个路由器相连的接口处，如果指明 `IP` 地址，那么 **两个路由器间的连线** 就构成了一个网络；
* `IP` 并非标识一个主机，而是 **标识一个主机与网络的一个连接**；
* 网桥连接的若干 `LAN` 仍属一个网络。

### 2. 子网

其实前面没有特别提及子网的概念。

因为 `A, B, C` 三类网络地址中，每个 **网络号** 都代表着一个网络，以及那个网络下一定数量的主机。（比如一个 `B` 类网络地址代表的网络可容纳 $2^{16}$ 个主机）

但实际面临的问题是，有很大部分的网络并不需要管理规定数量的主机，进而造成 `IP` 地址的极大浪费。

也就是说，之前所说的网络地址，是完完全全基于 `IP` 三类地址给出的。现在这里提到的子网，是在三类地址规定的 **某网络号代表的网络** 下，再划分 **一系列子网络**。

#### i. 子网掩码

所以明白了为什么叫 “三层网络”。是因为原来叫 “两层”。如果在中间开一层子网，那不就是三层了？

所以在 “三层网络” 下，一台主机的 `IP` 地址，由 **网络号**、**子网号** 与 **主机号** 三部分组成。而 **子网掩码** 也就是 **网络号+子网号** 的部分为 1。

#### ii. 网络前缀

上面说的 **子网掩码** 在网络划分子网中可以很 “保守”——比如对一个大网络 145.13.0.0，使用 255.255.127.0 作为子网掩码，那就可以拆出两个来。

但完完全全可以在一个网络里面用多个子网掩码（**VLSM**）。

为方便表示网络中不定长度的子网掩码，用 **CIDR(Classless Inter-Domain Routing)** （画斜线表示掩码）的标记方法来代替 **网络号+子网号**。

那么很明显，在路由器中，应该用 **最长前缀匹配** 方式来决定某包的下一跳地址。（如果不是最长前缀，那就飞到其他子网里面了，第一步走错后，不可能在那个 **非最长前缀** 的子网中找到目标子网）

### 3. NAT / PAT（网络地址转换）

没什么好说的，要么一对一，要么使用端口映射子网内主机的 `IP-Port`。

### 4. IP Protocol

不多说，建议直接看 [RFC-791](https://datatracker.ietf.org/doc/html/rfc791)。

## 七、路由选择

路由选择算法和 **构造路由表** 的 **路由算法** 并不是一回事。也不是前面所说的，简简单单的 **最长前缀匹配** 问题。

之前寻路只是太过抽象的纸上谈兵，甚至没有涉及子网。

### 1. 路由表格式

其实多少心里应该有个概念了：

|掩码|目的地址|下一跳|标志|引用计数|使用|接口|
|-|-|-|-|-|-|-|
|255.0.0.0|124.0.0.0|145.6.7.23|UG|4|20|m2|
|...|...|...|...|...|...|...|

这是课件上的例子。

每一项就是一个包 / 一个流 / 多个流所走的路由。对于 **标志** 一栏，有以下标识可选：

* U：这一条路由记录可以工作；
* G：我在这条路由记录中扮演网关，并将其转发到其他子网中；
* H：这一条路由记录被我直接指定了特定主机地址。

我们管有 `G` 叫 **间接交付**，反之，被称为 **直接交付**。（都 **连在这个路由器** 上，自然就由 **当前** 这台路由器 **直接交付** 给了目标网络）

我们管有 `H` 叫 **特定主机**，反之，被称为 **特定网络**。（特定主机就是那个 **目的地址** 是主机实际 `IP`，而非主机 **所在网络** 的 **网络地址**）

### 2. 网关协议

对于一个网关，它根据数据包的下一跳执行对应的协议——内部网关协议（`IGP`）、外部网关协议（`EGP`）。

`IGP / EGP` 都是一类协议的总称。

### 3. 转发过程

直接抄课件了，毕竟这段很精髓：

1. 从收到的 `IP` 数据包首部提取目的 `IP` 地址 `dst`。
2. **先判断是否直接交付**。用与路由器 **直接相连** 的网络的子网掩码和 `dst` 相与，检查结果是否和网络地址匹配。
3. **判断是否能特定主机路由**。如果路由表中有 **目的地址为 dst** 的 **特定主机路由**，就传给指明的下一跳路由器。
4. **判断是否能特定网络路由**。用路由表中各特定网络路由的子网掩码与 `dst` 相与，检查结果是否和目的网络地址匹配。
5. **判断是否能默认路由**。如果有默认路由，就传给默认路由指定的下一跳路由器。
6. 报错。

总体，要保持这样三个精神：

1. 先看近，再看远；（能直连就不要间接连接）
2. 先看主机，再看网络；（能特定主机就不看特定网络）
3. 默认路由优先级最小。（最后处理默认路由）

做题的时候，可以把 路由器的路由表 手动按照上面的过程要求去排序：

* 最上面的：`U` / `UD`（无 `G` 代表是直连的）
* 中间的：`UGD`（有 `D` 说明是特定主机）
* 下面的：`UG`（`UG` 代表特定网络）
* 最下面的：`0.0.0.0 | UG`（默认路由）
